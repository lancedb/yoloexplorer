{"version":3,"sources":["index.tsx"],"names":["labelDiv","document","body","appendChild","createElement","label","createTextNode","container","classList","add","selected_component_values","Streamlit","events","addEventListener","RENDER_EVENT","event","data","detail","theme","style","font","color","textColor","base","querySelectorAll","forEach","el","remove","textContent","args","images","captions","childNodes","length","image","i","item","box","img","src","caption","undefined","includes","push","onclick","contains","splice","indexOf","sort","setComponentValue","setFrameHeight","setComponentReady"],"mappings":"uJAAA,kBAEMA,EAAWC,SAASC,KAAKC,YAAYF,SAASG,cAAc,UAC5DC,EAAQL,EAASG,YAAYF,SAASK,eAAe,KACrDC,EAAYN,SAASC,KAAKC,YAAYF,SAASG,cAAc,QACnEG,EAAUC,UAAUC,IAAI,aACxB,IAAMC,EAAsC,GAuF5CC,IAAUC,OAAOC,iBAAiBF,IAAUG,cAhF5C,SAAkBC,GAEhB,IAAMC,EAAQD,EAAkCE,OAE5CD,EAAKE,QACPlB,EAASmB,MAAMC,KAAOJ,EAAKE,MAAME,KACjCpB,EAASmB,MAAME,MAAQL,EAAKE,MAAMI,UACV,SAApBN,EAAKE,MAAMK,KACbtB,SAASC,KAAKsB,iBAAiB,kBAAkBC,SAAQ,SAACC,GACxDA,EAAGlB,UAAUC,IAAI,WAGnBR,SAASC,KAAKsB,iBAAiB,kBAAkBC,SAAQ,SAACC,GACxDA,EAAGlB,UAAUmB,OAAO,YAO1BtB,EAAMuB,YAAcZ,EAAKa,KAAL,MACpB,IAAIC,EAASd,EAAKa,KAAL,OACTE,EAAWf,EAAKa,KAAL,SAGqB,IAAhCtB,EAAUyB,WAAWC,SACvBH,EAAOL,SAAQ,SAACS,EAAeC,GAC7B,IAAIC,EAAO7B,EAAUJ,YAAYF,SAASG,cAAc,QACxDgC,EAAK5B,UAAUC,IAAI,SACsB,IAArCO,EAAKa,KAAL,qBACFO,EAAK5B,UAAUC,IAAI,WAGrB,IAAI4B,EAAMD,EAAKjC,YAAYF,SAASG,cAAc,QAClDiC,EAAI7B,UAAUC,IAAI,aAElB,IAAI6B,EAAMD,EAAIlC,YAAYF,SAASG,cAAc,QAIjD,GAHAkC,EAAI9B,UAAUC,IAAI,SAClB6B,EAAIC,IAAML,EAENH,EAAU,CACZ,IAAIS,EAAUJ,EAAKjC,YAAYF,SAASG,cAAc,QACtDoC,EAAQhC,UAAUC,IAAI,WACtB+B,EAAQZ,YAAcG,EAASI,QAIJM,IAAzBzB,EAAKa,KAAL,SAAsCb,EAAKa,KAAL,QAAqBa,SAASP,KACtEE,EAAI7B,UAAUC,IAAI,YAClB6B,EAAI9B,UAAUC,IAAI,YAClBC,EAA0BiC,KAAKR,IAGjCG,EAAIM,QAAU,WAERP,EAAI7B,UAAUqC,SAAS,aACzBnC,EAA0BoC,OAAOpC,EAA0BqC,QAAQZ,GAAI,GACvEE,EAAI7B,UAAUmB,OAAO,YACrBW,EAAI9B,UAAUmB,OAAO,cAErBjB,EAA0BiC,KAAKR,GAC/BE,EAAI7B,UAAUC,IAAI,YAClB6B,EAAI9B,UAAUC,IAAI,aAEpBC,EAA0BsC,OAC1BrC,IAAUsC,kBAAkBvC,OAIhCC,IAAUsC,kBAAkBvC,IAO9BC,IAAUuC,oBAQZvC,IAAUwC,oBAIVxC,IAAUuC,mB","file":"static/js/main.c396fd5a.chunk.js","sourcesContent":["import { Streamlit, RenderData } from \"streamlit-component-lib\"\n\nconst labelDiv = document.body.appendChild(document.createElement(\"label\"))\nconst label = labelDiv.appendChild(document.createTextNode(\"\"))\nconst container = document.body.appendChild(document.createElement(\"div\"))\ncontainer.classList.add(\"container\")\nconst selected_component_values: number[] = []\n\n/**\n * The component's render function. This will be called immediately after\n * the component is initially loaded, and then again every time the\n * component gets new data from Python.\n */\nfunction onRender(event: Event): void {\n  // Get the RenderData from the event\n  const data = (event as CustomEvent<RenderData>).detail\n\n  if (data.theme) {\n    labelDiv.style.font = data.theme.font\n    labelDiv.style.color = data.theme.textColor\n    if (data.theme.base === \"dark\") {\n      document.body.querySelectorAll(\".box, .caption\").forEach((el) => {\n        el.classList.add(\"dark\")\n      })\n    } else {\n      document.body.querySelectorAll(\".box, .caption\").forEach((el) => {\n        el.classList.remove(\"dark\")\n      })\n    }\n\n    // TODO: Gray out the component if it's disabled.\n  }\n\n  label.textContent = data.args[\"label\"]\n  let images = data.args[\"images\"]\n  let captions = data.args[\"captions\"]\n  // console.log(captions)\n\n  if (container.childNodes.length === 0) {\n    images.forEach((image: string, i: number) => {\n      let item = container.appendChild(document.createElement(\"div\"))\n      item.classList.add(\"item\")\n      if (data.args[\"use_container_width\"] === true) {\n        item.classList.add(\"stretch\")\n      }\n\n      let box = item.appendChild(document.createElement(\"div\"))\n      box.classList.add(\"image-box\")\n\n      let img = box.appendChild(document.createElement(\"img\"))\n      img.classList.add(\"image\")\n      img.src = image\n\n      if (captions) {\n        let caption = item.appendChild(document.createElement(\"div\"))\n        caption.classList.add(\"caption\")\n        caption.textContent = captions[i]\n      }\n\n      // check if i is in the index array\n      if (data.args[\"indices\"] !== undefined && data.args[\"indices\"].includes(i)) {\n        box.classList.add(\"selected\")\n        img.classList.add(\"selected\")\n        selected_component_values.push(i)\n      }\n\n      img.onclick = function () {\n        // check if the image is already selected, then un-select it and remove it from the array\n        if (box.classList.contains(\"selected\")) {\n          selected_component_values.splice(selected_component_values.indexOf(i), 1)\n          box.classList.remove(\"selected\")\n          img.classList.remove(\"selected\")\n        } else {\n          selected_component_values.push(i)\n          box.classList.add(\"selected\")\n          img.classList.add(\"selected\")\n        }\n        selected_component_values.sort()\n        Streamlit.setComponentValue(selected_component_values)\n      }\n    })\n    // return selected_component_values\n    Streamlit.setComponentValue(selected_component_values)\n  }\n\n  // We tell Streamlit to update our frameHeight after each render event, in\n  // case it has changed. (This isn't strictly necessary for the example\n  // because our height stays fixed, but this is a low-cost function, so\n  // there's no harm in doing it redundantly.)\n  Streamlit.setFrameHeight()\n}\n\n// Attach our `onRender` handler to Streamlit's render event.\nStreamlit.events.addEventListener(Streamlit.RENDER_EVENT, onRender)\n\n// Tell Streamlit we're ready to start receiving data. We won't get our\n// first RENDER_EVENT until we call this function.\nStreamlit.setComponentReady()\n\n// Finally, tell Streamlit to update our initial height. We omit the\n// `height` parameter here to have it default to our scrollHeight.\nStreamlit.setFrameHeight()\n"],"sourceRoot":""}